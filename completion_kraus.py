# script to build deep kraus model for SPD matrix completion 
# train and evaluate from data generated by make_data_completion.py
#

from __future__ import print_function

import os
os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3' 

import matplotlib.pyplot as plt
import keras
from keras.models import Sequential
from keras import backend as K
from keras.layers import Activation, Dropout, BatchNormalization
from keras.callbacks import ModelCheckpoint, ReduceLROnPlateau
from KrausLayer import KrausLayer
from PSDReluLayer import PSDReluLayer
import tensorflow as tf
import numpy as np
import sys

def mse_masked_loss(y_true, y_pred):
    mask = tf.cast(tf.not_equal(y_true, 0), tf.float32)
    diff = tf.multiply(tf.square(y_pred-y_true), mask)
    loss = tf.reduce_mean(diff)
    return loss

rescale_prediction = True

batch_size = 4
epochs = 50

#context="100_7_4_3"

try:
  context = sys.argv[1]
  fold = int(sys.argv[2])
except:
  fold = 0
  print('usage: '+sys.argv[0]+' <context> <fold> <rank> <depth> <intermediate_dims>')
  print('default: fold = 0; rank = 10; depth = 1 ; intermediate_dims = 15')

context2 = context + '_'+str(fold)
print('context', context, context2)
n = int(context.split('_')[0])

try:
  rank = int(sys.argv[3])
except:
  rank = 10

try:
  depth = int(sys.argv[4])
  intermediate_dims = int(sys.argv[5])
except:
  depth = 1
  intermediate_dims = -1

try:
  nl = int(sys.argv[6]) # non linearity
except:
  nl = 0

try:
  eps = float(sys.argv[7])
except:
  eps = 0.0001

filename = 'results_completion3/'+str(context2)+'_'+str(rank)+'_'+str(depth)+'_'+str(intermediate_dims)+'_'+str(nl)+'_'+str(eps)+'.out'
print(filename)

# reset given model
def reset_weights(model):
    session = K.get_session()
    for layer in model.layers: 
        if isinstance(layer, keras.engine.network.Network):
            reset_weights(layer)
            continue
        for v in layer.__dict__.values():
            if hasattr(v, 'initializer'):
                v.initializer.run(session=session)

# the data, generated by toy_experiments.py
try:
  M = np.load('data/completion/M_'+context2+'.npy')
except:
  M = np.load('data/completion/M_'+context+'.npy')
M_atrou = np.load('data/completion/M_atrou_'+context2+'.npy')
X = np.load('data/completion/X_'+context2+'.npy')
Y = np.load('data/completion/Y_'+context2+'.npy')
Xt = np.load('data/completion/Xt_'+context2+'.npy')
Yt = np.load('data/completion/Yt_'+context2+'.npy')

n_max = 3500
n = X.shape[0]
if n > n_max:
  l_idx = list(range(n_max))
  np.random.shuffle(l_idx)
  l_idx = l_idx[:n_max]
  X = X[l_idx]
  Y = Y[l_idx]

p = X.shape[-1]
q = Y.shape[-1]

vmin = float(np.min(M))
vmax = float(np.max(M))

input_shape = X[0].shape

model = Sequential()

for d in range(depth):
    dims = intermediate_dims
    if d == depth - 1: dims = Y[0].shape[0]
    if d == 0: model.add(KrausLayer(dims, rank, input_shape=input_shape))
    else: model.add(KrausLayer(dims, rank))
    if nl > 0 and d < depth - 1: model.add(PSDReluLayer(eps))
print(model.summary())
model.compile(loss=mse_masked_loss, optimizer=keras.optimizers.Adam())

scores = []
diffs = []
repeat = 1
best = 10000
for i in range(repeat): # repeat learning n times
    reset_weights(model)
    loss = model.fit(X, Y, batch_size=batch_size, epochs=epochs, verbose=1)
    mse = model.evaluate(Xt, Yt, verbose=0)
    scores.append(mse)
    print('mse = ', mse)

    ## reconstruct complete M matrix
    mat = np.array(M_atrou)
    mat_atrou = np.array(M_atrou)

    # make mask
    mask = np.array(M_atrou)
    mask[mask > 0.] = 1.

    # make reverse mask
    rmask = np.array(M_atrou)
    rmask[rmask > 0.] = -1.
    rmask[rmask == 0.] = 1.
    rmask[rmask == -1.] = 0.

    # predict and only replace missing values
    Ypred = model.predict(Xt)
    for j in range(Xt.shape[0]):
        c = np.where(Xt[j] == 1.)
        p1, p2 = int(c[0]), int(c[1])
        idx = slice(p1*q,(p1+1)*q)
        idy = slice(p2*q,(p2+1)*q)
        
        # rescale prediction to fit existing entries
        if rescale_prediction:
            mask = np.array(Yt[j])
            mask[mask > 0.] = 1.
            yt = np.multiply(Yt[j], mask)
            yp = np.multiply(Ypred[j], mask)
        
            try:
                emin = np.min(yt[np.nonzero(yt)])
                emax = np.max(yt[np.nonzero(yt)])
            except:
                emin = 0.
                emax = 1.
        
            try:
                pmin = np.min(yp[np.nonzero(yp)])
                pmax = np.max(yp[np.nonzero(yp)])
            except:
                pmin = 0.
                pmax = 1.

            if pmax - pmin > 0.00001:
                Ypred[j] = (Ypred[j] - pmin) / (pmax - pmin)
            else:
                Ypred[j] = Ypred[j] - pmin
            if emax - emin > 0.00001:
                Ypred[j] = Ypred[j] * (emax - emin) + emin
            else:
                Ypred[j] = Ypred[j] + emin
            
        mat[idx, idy] += np.multiply(Ypred[j], rmask[idx, idy])
        
    # evaluate difference with original matrix
    diff = np.linalg.norm(M - mat)
    diffs.append(diff)
    print('diff:', diff, 'diff_atrou', np.linalg.norm(M - mat_atrou))
    
    if (diff > 1000): sys.exit(0)

    if diff < best:
      diff = best
      # save only the best fold
      plt.figure()
      plt.matshow(M, fignum=False, vmin=vmin, vmax=vmax)
      plt.savefig('results_completion3/M_orig_'+str(context2)+'_'+str(rank)+'_'+str(depth)+'_'+str(intermediate_dims)+'_'+str(nl)+'.png')
      plt.close()

      plt.figure()
      plt.matshow(mat_atrou, fignum=False, vmin=vmin, vmax=vmax)
      plt.savefig('results_completion3/M_atrou_'+str(context2)+'_'+str(rank)+'_'+str(depth)+'_'+str(intermediate_dims)+'_'+str(nl)+'.png')
      plt.close()

      plt.figure()
      plt.matshow(mat, fignum=False, vmin=vmin, vmax=vmax)
      plt.savefig('results_completion3/M_compl_'+str(context2)+'_'+str(rank)+'_'+str(depth)+'_'+str(intermediate_dims)+'_'+str(nl)+'_'+str(eps)+'.png')
      plt.close()

      np.save('results_completion3/M_compl_'+str(context2)+'_'+str(rank)+'_'+str(depth)+'_'+str(intermediate_dims)+'_'+str(nl)+'_'+str(eps)+'.npy', mat)

print('mean mse:', np.mean(scores), np.std(scores))
print('mean diff:', np.mean(diffs), np.std(diffs))

f = open(filename, 'w')
f.write('Train loss: '+ str(loss.history['loss'][-1])+ ' Test loss: '+ str(np.mean(scores))+' '+ str(np.std(scores))+' Norm: ' + str(np.mean(diffs)) + ' ' + str(np.std(diffs)) + ' n: '+ str(n)+' '+ str(fold)+ ' rank: '+ str(rank)+ ' depth: '+ str(depth)+ ' intermediate_dims: '+ str(intermediate_dims)+ ' nl: '+ str(nl)+' eps: '+str(eps)+ ' nb_params '+ str(model.count_params()) + '\n')
f.close()

